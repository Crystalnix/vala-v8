/* girepository.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "GI", lower_case_cprefix = "gi_", gir_namespace = "GIRepository", gir_version = "2.0")]
namespace GI {
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class ArgInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "g_base_info_gtype_get_type ()", cheader_filename = "girepository.h")]
	public class BaseInfo {
		[CCode (has_construct_function = false)]
		protected BaseInfo ();
		[CCode (cname = "g_base_info_get_type")]
		public InfoType get_type ();
		[CCode (cname = "g_base_info_equal")]
		public bool equal (GI.BaseInfo info2);
		[CCode (cname = "g_base_info_get_attribute")]
		public unowned string get_attribute (string name);
		[CCode (cname = "g_base_info_get_container")]
		public unowned GI.BaseInfo get_container ();
		[CCode (cname = "g_base_info_get_name")]
		public unowned string get_name ();
		[CCode (cname = "g_base_info_get_namespace")]
		public unowned string get_namespace ();
		[CCode (cname = "g_base_info_get_typelib")]
		public GI.Typelib get_typelib ();
		[CCode (cname = "g_base_info_is_deprecated")]
		public bool is_deprecated ();
		[CCode (cname = "g_base_info_iterate_attributes")]
		public bool iterate_attributes (GI.AttributeIter iterator, out unowned string name, out unowned string value);
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class CallableInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class CallbackInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class ConstantInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class EnumInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class ErrorDomainInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class FieldInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", type_id = "g_base_info_gtype_get_type ()", cheader_filename = "girepository.h")]
	public class FunctionInfo : GI.BaseInfo {
    	[CCode (cname = "g_function_info_get_flags", cheader_filename = "girepository.h")]
    	public GI.FunctionInfoFlags get_flags ();
    	[CCode (cname = "g_function_info_get_property", cheader_filename = "girepository.h")]
    	public GI.PropertyInfo get_property ();
    	[CCode (cname = "g_function_info_get_symbol", cheader_filename = "girepository.h")]
    	public unowned string get_symbol ();
    	[CCode (cname = "g_function_info_get_vfunc", cheader_filename = "girepository.h")]
    	public GI.VFuncInfo get_vfunc ();
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class InterfaceInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class ObjectInfo : GI.BaseInfo {
    	[CCode (cname = "g_object_info_find_method", cheader_filename = "girepository.h")]
    	public GI.FunctionInfo find_method (string name);
    	[CCode (cname = "g_object_info_find_vfunc", cheader_filename = "girepository.h")]
    	public GI.VFuncInfo find_vfunc (string name);
    	[CCode (cname = "g_object_info_get_abstract", cheader_filename = "girepository.h")]
    	public bool get_abstract ();
    	[CCode (cname = "g_object_info_get_class_struct", cheader_filename = "girepository.h")]
    	public GI.StructInfo get_class_struct ();
    	[CCode (cname = "g_object_info_get_constant", cheader_filename = "girepository.h")]
    	public GI.ConstantInfo get_constant (int n);
    	[CCode (cname = "g_object_info_get_field", cheader_filename = "girepository.h")]
    	public GI.FieldInfo get_field (int n);
    	[CCode (cname = "g_object_info_get_fundamental", cheader_filename = "girepository.h")]
    	public bool get_fundamental ();
    	[CCode (cname = "g_object_info_get_get_value_function", cheader_filename = "girepository.h")]
    	public unowned string get_get_value_function ();
    	[CCode (cname = "g_object_info_get_interface", cheader_filename = "girepository.h")]
    	public GI.InterfaceInfo get_interface (int n);
    	[CCode (cname = "g_object_info_get_method", cheader_filename = "girepository.h")]
    	public GI.FunctionInfo get_method (int n);
    	[CCode (cname = "g_object_info_get_n_constants", cheader_filename = "girepository.h")]
    	public int get_n_constants ();
    	[CCode (cname = "g_object_info_get_n_fields", cheader_filename = "girepository.h")]
    	public int get_n_fields ();
    	[CCode (cname = "g_object_info_get_n_interfaces", cheader_filename = "girepository.h")]
    	public int get_n_interfaces ();
    	[CCode (cname = "g_object_info_get_n_methods", cheader_filename = "girepository.h")]
    	public int get_n_methods ();
    	[CCode (cname = "g_object_info_get_n_properties", cheader_filename = "girepository.h")]
    	public int get_n_properties ();
    	[CCode (cname = "g_object_info_get_n_signals", cheader_filename = "girepository.h")]
    	public int get_n_signals ();
    	[CCode (cname = "g_object_info_get_n_vfuncs", cheader_filename = "girepository.h")]
    	public int get_n_vfuncs ();
    	[CCode (cname = "g_object_info_get_parent", cheader_filename = "girepository.h")]
    	public GI.ObjectInfo get_parent ();
    	[CCode (cname = "g_object_info_get_property", cheader_filename = "girepository.h")]
    	public GI.PropertyInfo get_property (int n);
    	[CCode (cname = "g_object_info_get_ref_function", cheader_filename = "girepository.h")]
    	public unowned string get_ref_function ();
    	[CCode (cname = "g_object_info_get_set_value_function", cheader_filename = "girepository.h")]
    	public unowned string get_set_value_function ();
    	[CCode (cname = "g_object_info_get_signal", cheader_filename = "girepository.h")]
    	public GI.SignalInfo get_signal (int n);
    	[CCode (cname = "g_object_info_get_type_init", cheader_filename = "girepository.h")]
    	public unowned string get_type_init ();
    	[CCode (cname = "g_object_info_get_type_name", cheader_filename = "girepository.h")]
    	public unowned string get_type_name ();
    	[CCode (cname = "g_object_info_get_unref_function", cheader_filename = "girepository.h")]
    	public unowned string get_unref_function ();
    	[CCode (cname = "g_object_info_get_vfunc", cheader_filename = "girepository.h")]
    	public GI.VFuncInfo get_vfunc (int n);
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class PropertyInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class RegisteredTypeInfo : GI.BaseInfo {
	}
	[CCode (cheader_filename = "girepository.h")]
	public class Repository : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Repository ();
		[CCode (cname = "g_irepository_dump")]
		public static bool dump (string arg) throws GLib.Error;
		[CCode (cname = "g_irepository_enumerate_versions")]
		public static GLib.List<string> enumerate_versions (GI.Repository? repository, string namespace_);
		[CCode (cname = "g_irepository_error_quark")]
		public static GLib.Quark error_quark ();
		[CCode (cname = "g_irepository_find_by_gtype")]
		public static GI.BaseInfo find_by_gtype (GI.Repository? repository, GLib.Type gtype);
		[CCode (cname = "g_irepository_find_by_name")]
		public static GI.BaseInfo find_by_name (GI.Repository? repository, string namespace_, string name);
		[CCode (cname = "g_irepository_get_c_prefix")]
		public static unowned string get_c_prefix (GI.Repository repository, string namespace_);
		[CCode (cname = "g_irepository_get_default")]
		public static unowned GI.Repository get_default ();
		[CCode (cname = "g_irepository_get_dependencies", array_length = false, array_null_terminated = true)]
		public static string[] get_dependencies (GI.Repository? repository, string namespace_);
		[CCode (cname = "g_irepository_get_info")]
		public static GI.BaseInfo get_info (GI.Repository? repository, string namespace_, int index);
		[CCode (cname = "g_irepository_get_loaded_namespaces", array_length = false, array_null_terminated = true)]
		public static string[] get_loaded_namespaces (GI.Repository? repository);
		[CCode (cname = "g_irepository_get_n_infos")]
		public static int get_n_infos (GI.Repository? repository, string namespace_);
		[CCode (cname = "g_irepository_get_search_path")]
		public static unowned GLib.SList<weak string> get_search_path ();
		[CCode (cname = "g_irepository_get_shared_library")]
		public static unowned string get_shared_library (GI.Repository? repository, string namespace_);
		[CCode (cname = "g_irepository_get_typelib_path")]
		public static unowned string get_typelib_path (GI.Repository repository, string namespace_);
		[CCode (cname = "g_irepository_get_version")]
		public static unowned string get_version (GI.Repository? repository, string namespace_);
		[CCode (cname = "g_irepository_is_registered")]
		public static bool is_registered (GI.Repository? repository, string namespace_, string? version);
		[CCode (cname = "g_irepository_load_typelib")]
		public static unowned string load_typelib (GI.Repository repository, GI.Typelib typelib, GI.RepositoryLoadFlags flags) throws GLib.Error;
		[CCode (cname = "g_irepository_prepend_search_path")]
		public static void prepend_search_path (string directory);
		[CCode (cname = "g_irepository_require")]
		public static GI.Typelib* require (GI.Repository? repository, string namespace_, string? version, GI.RepositoryLoadFlags flags) throws GLib.Error;
		[CCode (cname = "g_irepository_require_private")]
		public static GI.Typelib require_private (GI.Repository? repository, string typelib_dir, string @namespace, string? version, GI.RepositoryLoadFlags flags) throws GLib.Error;
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class SignalInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class StructInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class TypeInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class UnionInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class VFuncInfo : GI.BaseInfo {
	}
	[Compact]
	[CCode (free_function = "g_boxed_free", cheader_filename = "girepository.h")]
	public class ValueInfo : GI.BaseInfo {
	}
	[CCode (type_id = "GI_TYPE_ATTRIBUTE_ITER", cheader_filename = "girepository.h")]
	public struct AttributeIter {
		public void* data;
		public void* data2;
		public void* data3;
		public void* data4;
	}
	[CCode (type_id = "GI_TYPE_TYPELIB", cheader_filename = "girepository.h")]
	public struct Typelib {
		[CCode (cname = "g_typelib_free")]
		public void free ();
		[CCode (cname = "g_typelib_get_namespace")]
		public unowned string get_namespace ();
		[CCode (cname = "g_typelib_symbol")]
		public bool symbol (string symbol_name, void* symbol);
	}
	[CCode (type_id = "GI_TYPE_UNRESOLVED_INFO", cheader_filename = "girepository.h")]
	public struct UnresolvedInfo {
	}
	[CCode (type_id = "GI_TYPE__ARGUMENT", cheader_filename = "girepository.h")]
	public struct _Argument {
		public bool v_boolean;
		public int8 v_int8;
		public uint8 v_uint8;
		public int16 v_int16;
		public uint16 v_uint16;
		public int32 v_int32;
		public uint32 v_uint32;
		public int64 v_int64;
		public uint64 v_uint64;
		public float v_float;
		public double v_double;
		public short v_short;
		public ushort v_ushort;
		public int v_int;
		public uint v_uint;
		public long v_long;
		public ulong v_ulong;
		public ssize_t v_ssize;
		public size_t v_size;
		public weak string v_string;
		public void* v_pointer;
	}
	[CCode (cname = "_GIBaseInfoStub", type_id = "GI_TYPE__BASEINFOSTUB", cheader_filename = "girepository.h")]
	public struct _BaseInfoStub {
		public int32 dummy1;
		public int32 dummy2;
		public void* dummy3;
		public void* dummy4;
		public void* dummy5;
		public uint32 dummy6;
		public uint32 dummy7;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] padding;
	}
	[CCode (cprefix = "GI_ARRAY_TYPE_", cheader_filename = "girepository.h")]
	public enum ArrayType {
		C,
		ARRAY,
		PTR_ARRAY,
		BYTE_ARRAY
	}
	[CCode (cprefix = "GI_DIRECTION_", cheader_filename = "girepository.h")]
	public enum Direction {
		IN,
		OUT,
		INOUT
	}
	[CCode (cprefix = "GI_FIELD_IS_", cheader_filename = "girepository.h")]
	[Flags]
	public enum FieldInfoFlags {
		READABLE,
		WRITABLE
	}
	[CCode (cprefix = "GI_FUNCTION_", cheader_filename = "girepository.h")]
	[Flags]
	public enum FunctionInfoFlags {
		IS_METHOD,
		IS_CONSTRUCTOR,
		IS_GETTER,
		IS_SETTER,
		WRAPS_VFUNC,
		THROWS
	}
	[CCode (cprefix = "GI_INFO_TYPE_", cheader_filename = "girepository.h")]
	public enum InfoType {
		INVALID,
		FUNCTION,
		CALLBACK,
		STRUCT,
		BOXED,
		ENUM,
		FLAGS,
		OBJECT,
		INTERFACE,
		CONSTANT,
		ERROR_DOMAIN,
		UNION,
		VALUE,
		SIGNAL,
		VFUNC,
		PROPERTY,
		FIELD,
		ARG,
		TYPE,
		UNRESOLVED
	}
	[CCode (cprefix = "G_IREPOSITORY_ERROR_", cheader_filename = "girepository.h")]
	public enum RepositoryError {
		TYPELIB_NOT_FOUND,
		NAMESPACE_MISMATCH,
		NAMESPACE_VERSION_CONFLICT,
		LIBRARY_NOT_FOUND
	}
	[CCode (cprefix = "G_IREPOSITORY_LOAD_FLAG_", cheader_filename = "girepository.h")]
	[Flags]
	public enum RepositoryLoadFlags {
		[CCode (cname = "G_IREPOSITORY_LOAD_FLAG_LAZY")]
		IREPOSITORY_LOAD_FLAG_LAZY
	}
	[CCode (cprefix = "GI_SCOPE_TYPE_", cheader_filename = "girepository.h")]
	public enum ScopeType {
		INVALID,
		CALL,
		ASYNC,
		NOTIFIED
	}
	[CCode (cprefix = "GI_TRANSFER_", cheader_filename = "girepository.h")]
	public enum Transfer {
		NOTHING,
		CONTAINER,
		EVERYTHING
	}
	[CCode (cprefix = "GI_TYPE_TAG_", cheader_filename = "girepository.h")]
	public enum TypeTag {
		VOID,
		BOOLEAN,
		INT8,
		UINT8,
		INT16,
		UINT16,
		INT32,
		UINT32,
		INT64,
		UINT64,
		FLOAT,
		DOUBLE,
		GTYPE,
		UTF8,
		FILENAME,
		ARRAY,
		INTERFACE,
		GLIST,
		GSLIST,
		GHASH,
		ERROR
	}
	[CCode (cprefix = "GI_VFUNC_MUST_", cheader_filename = "girepository.h")]
	[Flags]
	public enum VFuncInfoFlags {
		CHAIN_UP,
		OVERRIDE,
		NOT_OVERRIDE
	}
	[CCode (cprefix = "G_INVOKE_ERROR_", cheader_filename = "girepository.h")]
	public errordomain InvokeError {
	    FAILED,
        SYMBOL_NOT_FOUND,
        ARGUMENT_MISMATCH
	}
	[CCode (cname = "g_arg_info_get_closure", cheader_filename = "girepository.h")]
	public static int arg_info_get_closure (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_get_destroy", cheader_filename = "girepository.h")]
	public static int arg_info_get_destroy (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_get_direction", cheader_filename = "girepository.h")]
	public static GI.Direction arg_info_get_direction (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_get_ownership_transfer", cheader_filename = "girepository.h")]
	public static GI.Transfer arg_info_get_ownership_transfer (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_get_scope", cheader_filename = "girepository.h")]
	public static GI.ScopeType arg_info_get_scope (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_get_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo arg_info_get_type (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_is_caller_allocates", cheader_filename = "girepository.h")]
	public static bool arg_info_is_caller_allocates (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_is_optional", cheader_filename = "girepository.h")]
	public static bool arg_info_is_optional (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_is_return_value", cheader_filename = "girepository.h")]
	public static bool arg_info_is_return_value (GI.ArgInfo info);
	[CCode (cname = "g_arg_info_load_type", cheader_filename = "girepository.h")]
	public static void arg_info_load_type (GI.ArgInfo info, out unowned GI.TypeInfo type);
	[CCode (cname = "g_arg_info_may_be_null", cheader_filename = "girepository.h")]
	public static bool arg_info_may_be_null (GI.ArgInfo info);
	[CCode (cname = "g_base_info_get_type", cheader_filename = "girepository.h")]
	public static GI.InfoType base_info_get_type (GI.BaseInfo info);
	[CCode (cname = "g_callable_info_get_arg", cheader_filename = "girepository.h")]
	public static GI.ArgInfo callable_info_get_arg (GI.CallableInfo info, int n);
	[CCode (cname = "g_callable_info_get_caller_owns", cheader_filename = "girepository.h")]
	public static GI.Transfer callable_info_get_caller_owns (GI.CallableInfo info);
	[CCode (cname = "g_callable_info_get_n_args", cheader_filename = "girepository.h")]
	public static int callable_info_get_n_args (GI.CallableInfo info);
	[CCode (cname = "g_callable_info_get_return_attribute", cheader_filename = "girepository.h")]
	public static unowned string callable_info_get_return_attribute (GI.CallableInfo info, string name);
	[CCode (cname = "g_callable_info_get_return_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo callable_info_get_return_type (GI.CallableInfo info);
	[CCode (cname = "g_callable_info_iterate_return_attributes", cheader_filename = "girepository.h")]
	public static bool callable_info_iterate_return_attributes (GI.CallableInfo info, GI.AttributeIter iterator, out unowned string name, out unowned string value);
	[CCode (cname = "g_callable_info_load_arg", cheader_filename = "girepository.h")]
	public static void callable_info_load_arg (GI.CallableInfo info, int n, out unowned GI.ArgInfo arg);
	[CCode (cname = "g_callable_info_load_return_type", cheader_filename = "girepository.h")]
	public static void callable_info_load_return_type (GI.CallableInfo info, out unowned GI.TypeInfo type);
	[CCode (cname = "g_callable_info_may_return_null", cheader_filename = "girepository.h")]
	public static bool callable_info_may_return_null (GI.CallableInfo info);
	[CCode (cname = "g_constant_info_get_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo constant_info_get_type (GI.ConstantInfo info);
	[CCode (cname = "g_enum_info_get_n_values", cheader_filename = "girepository.h")]
	public static int enum_info_get_n_values (GI.EnumInfo info);
	[CCode (cname = "g_enum_info_get_storage_type", cheader_filename = "girepository.h")]
	public static GI.TypeTag enum_info_get_storage_type (GI.EnumInfo info);
	[CCode (cname = "g_enum_info_get_value", cheader_filename = "girepository.h")]
	public static GI.ValueInfo enum_info_get_value (GI.EnumInfo info, int n);
	[CCode (cname = "g_error_domain_info_get_codes", cheader_filename = "girepository.h")]
	public static GI.InterfaceInfo error_domain_info_get_codes (GI.ErrorDomainInfo info);
	[CCode (cname = "g_error_domain_info_get_quark", cheader_filename = "girepository.h")]
	public static unowned string error_domain_info_get_quark (GI.ErrorDomainInfo info);
	[CCode (cname = "g_field_info_get_flags", cheader_filename = "girepository.h")]
	public static GI.FieldInfoFlags field_info_get_flags (GI.FieldInfo info);
	[CCode (cname = "g_field_info_get_offset", cheader_filename = "girepository.h")]
	public static int field_info_get_offset (GI.FieldInfo info);
	[CCode (cname = "g_field_info_get_size", cheader_filename = "girepository.h")]
	public static int field_info_get_size (GI.FieldInfo info);
	[CCode (cname = "g_field_info_get_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo field_info_get_type (GI.FieldInfo info);
	[CCode (cname = "g_function_info_get_flags", cheader_filename = "girepository.h")]
	public static GI.FunctionInfoFlags function_info_get_flags (GI.FunctionInfo info);
	[CCode (cname = "g_function_info_get_property", cheader_filename = "girepository.h")]
	public static GI.PropertyInfo function_info_get_property (GI.FunctionInfo info);
	[CCode (cname = "g_function_info_get_symbol", cheader_filename = "girepository.h")]
	public static unowned string function_info_get_symbol (GI.FunctionInfo info);
	[CCode (cname = "g_function_info_get_vfunc", cheader_filename = "girepository.h")]
	public static GI.VFuncInfo function_info_get_vfunc (GI.FunctionInfo info);
	[CCode (cname = "g_info_new", cheader_filename = "girepository.h")]
	public static GI.BaseInfo info_new (GI.InfoType type, GI.BaseInfo container, GI.Typelib typelib, uint32 offset);
	[CCode (cname = "g_info_type_to_string", cheader_filename = "girepository.h")]
	public static unowned string info_type_to_string (GI.InfoType type);
	[CCode (cname = "g_interface_info_find_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo interface_info_find_method (GI.InterfaceInfo info, string name);
	[CCode (cname = "g_interface_info_find_vfunc", cheader_filename = "girepository.h")]
	public static GI.VFuncInfo interface_info_find_vfunc (GI.InterfaceInfo info, string name);
	[CCode (cname = "g_interface_info_get_constant", cheader_filename = "girepository.h")]
	public static GI.ConstantInfo interface_info_get_constant (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_interface_info_get_iface_struct", cheader_filename = "girepository.h")]
	public static GI.StructInfo interface_info_get_iface_struct (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo interface_info_get_method (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_interface_info_get_n_constants", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_constants (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_n_methods", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_methods (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_n_prerequisites", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_prerequisites (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_n_properties", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_properties (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_n_signals", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_signals (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_n_vfuncs", cheader_filename = "girepository.h")]
	public static int interface_info_get_n_vfuncs (GI.InterfaceInfo info);
	[CCode (cname = "g_interface_info_get_prerequisite", cheader_filename = "girepository.h")]
	public static GI.BaseInfo interface_info_get_prerequisite (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_interface_info_get_property", cheader_filename = "girepository.h")]
	public static GI.PropertyInfo interface_info_get_property (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_interface_info_get_signal", cheader_filename = "girepository.h")]
	public static GI.SignalInfo interface_info_get_signal (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_interface_info_get_vfunc", cheader_filename = "girepository.h")]
	public static GI.VFuncInfo interface_info_get_vfunc (GI.InterfaceInfo info, int n);
	[CCode (cname = "g_invoke_error_quark", cheader_filename = "girepository.h")]
	public static GLib.Quark invoke_error_quark ();
	[CCode (cname = "g_property_info_get_flags", cheader_filename = "girepository.h")]
	public static GLib.ParamFlags property_info_get_flags (GI.PropertyInfo info);
	[CCode (cname = "g_property_info_get_ownership_transfer", cheader_filename = "girepository.h")]
	public static GI.Transfer property_info_get_ownership_transfer (GI.PropertyInfo info);
	[CCode (cname = "g_property_info_get_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo property_info_get_type (GI.PropertyInfo info);
	[CCode (cname = "g_registered_type_info_get_g_type", cheader_filename = "girepository.h")]
	public static GLib.Type registered_type_info_get_g_type (GI.RegisteredTypeInfo info);
	[CCode (cname = "g_registered_type_info_get_type_init", cheader_filename = "girepository.h")]
	public static unowned string registered_type_info_get_type_init (GI.RegisteredTypeInfo info);
	[CCode (cname = "g_registered_type_info_get_type_name", cheader_filename = "girepository.h")]
	public static unowned string registered_type_info_get_type_name (GI.RegisteredTypeInfo info);
	[CCode (cname = "g_signal_info_get_class_closure", cheader_filename = "girepository.h")]
	public static GI.VFuncInfo signal_info_get_class_closure (GI.SignalInfo info);
	[CCode (cname = "g_signal_info_get_flags", cheader_filename = "girepository.h")]
	public static GLib.SignalFlags signal_info_get_flags (GI.SignalInfo info);
	[CCode (cname = "g_signal_info_true_stops_emit", cheader_filename = "girepository.h")]
	public static bool signal_info_true_stops_emit (GI.SignalInfo info);
	[CCode (cname = "g_struct_info_find_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo struct_info_find_method (GI.StructInfo info, string name);
	[CCode (cname = "g_struct_info_get_alignment", cheader_filename = "girepository.h")]
	public static size_t struct_info_get_alignment (GI.StructInfo info);
	[CCode (cname = "g_struct_info_get_field", cheader_filename = "girepository.h")]
	public static GI.FieldInfo struct_info_get_field (GI.StructInfo info, int n);
	[CCode (cname = "g_struct_info_get_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo struct_info_get_method (GI.StructInfo info, int n);
	[CCode (cname = "g_struct_info_get_n_fields", cheader_filename = "girepository.h")]
	public static int struct_info_get_n_fields (GI.StructInfo info);
	[CCode (cname = "g_struct_info_get_n_methods", cheader_filename = "girepository.h")]
	public static int struct_info_get_n_methods (GI.StructInfo info);
	[CCode (cname = "g_struct_info_get_size", cheader_filename = "girepository.h")]
	public static size_t struct_info_get_size (GI.StructInfo info);
	[CCode (cname = "g_struct_info_is_foreign", cheader_filename = "girepository.h")]
	public static bool struct_info_is_foreign (GI.StructInfo info);
	[CCode (cname = "g_struct_info_is_gtype_struct", cheader_filename = "girepository.h")]
	public static bool struct_info_is_gtype_struct (GI.StructInfo info);
	[CCode (cname = "g_type_info_get_array_fixed_size", cheader_filename = "girepository.h")]
	public static int type_info_get_array_fixed_size (GI.TypeInfo info);
	[CCode (cname = "g_type_info_get_array_length", cheader_filename = "girepository.h")]
	public static int type_info_get_array_length (GI.TypeInfo info);
	[CCode (cname = "g_type_info_get_array_type", cheader_filename = "girepository.h")]
	public static GI.ArrayType type_info_get_array_type (GI.TypeInfo info);
	[CCode (cname = "g_type_info_get_error_domain", cheader_filename = "girepository.h")]
	public static GI.ErrorDomainInfo type_info_get_error_domain (GI.TypeInfo info, int n);
	[CCode (cname = "g_type_info_get_interface", cheader_filename = "girepository.h")]
	public static GI.BaseInfo type_info_get_interface (GI.TypeInfo info);
	[CCode (cname = "g_type_info_get_n_error_domains", cheader_filename = "girepository.h")]
	public static int type_info_get_n_error_domains (GI.TypeInfo info);
	[CCode (cname = "g_type_info_get_param_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo type_info_get_param_type (GI.TypeInfo info, int n);
	[CCode (cname = "g_type_info_get_tag", cheader_filename = "girepository.h")]
	public static GI.TypeTag type_info_get_tag (GI.TypeInfo info);
	[CCode (cname = "g_type_info_is_pointer", cheader_filename = "girepository.h")]
	public static bool type_info_is_pointer (GI.TypeInfo info);
	[CCode (cname = "g_type_info_is_zero_terminated", cheader_filename = "girepository.h")]
	public static bool type_info_is_zero_terminated (GI.TypeInfo info);
	[CCode (cname = "g_type_tag_to_string", cheader_filename = "girepository.h")]
	public static unowned string type_tag_to_string (GI.TypeTag type);
	[CCode (cname = "g_union_info_find_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo union_info_find_method (GI.UnionInfo info, string name);
	[CCode (cname = "g_union_info_get_alignment", cheader_filename = "girepository.h")]
	public static size_t union_info_get_alignment (GI.UnionInfo info);
	[CCode (cname = "g_union_info_get_discriminator", cheader_filename = "girepository.h")]
	public static GI.ConstantInfo union_info_get_discriminator (GI.UnionInfo info, int n);
	[CCode (cname = "g_union_info_get_discriminator_offset", cheader_filename = "girepository.h")]
	public static int union_info_get_discriminator_offset (GI.UnionInfo info);
	[CCode (cname = "g_union_info_get_discriminator_type", cheader_filename = "girepository.h")]
	public static GI.TypeInfo union_info_get_discriminator_type (GI.UnionInfo info);
	[CCode (cname = "g_union_info_get_field", cheader_filename = "girepository.h")]
	public static GI.FieldInfo union_info_get_field (GI.UnionInfo info, int n);
	[CCode (cname = "g_union_info_get_method", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo union_info_get_method (GI.UnionInfo info, int n);
	[CCode (cname = "g_union_info_get_n_fields", cheader_filename = "girepository.h")]
	public static int union_info_get_n_fields (GI.UnionInfo info);
	[CCode (cname = "g_union_info_get_n_methods", cheader_filename = "girepository.h")]
	public static int union_info_get_n_methods (GI.UnionInfo info);
	[CCode (cname = "g_union_info_get_size", cheader_filename = "girepository.h")]
	public static size_t union_info_get_size (GI.UnionInfo info);
	[CCode (cname = "g_union_info_is_discriminated", cheader_filename = "girepository.h")]
	public static bool union_info_is_discriminated (GI.UnionInfo info);
	[CCode (cname = "g_value_info_get_value", cheader_filename = "girepository.h")]
	public static long value_info_get_value (GI.ValueInfo info);
	[CCode (cname = "g_vfunc_info_get_flags", cheader_filename = "girepository.h")]
	public static GI.VFuncInfoFlags vfunc_info_get_flags (GI.VFuncInfo info);
	[CCode (cname = "g_vfunc_info_get_invoker", cheader_filename = "girepository.h")]
	public static GI.FunctionInfo vfunc_info_get_invoker (GI.VFuncInfo info);
	[CCode (cname = "g_vfunc_info_get_offset", cheader_filename = "girepository.h")]
	public static int vfunc_info_get_offset (GI.VFuncInfo info);
	[CCode (cname = "g_vfunc_info_get_signal", cheader_filename = "girepository.h")]
	public static GI.SignalInfo vfunc_info_get_signal (GI.VFuncInfo info);
}
